#!/usr/bin/env python3
"""
Minimal PSF generator in pure Python:
  - Parses a CHARMM RTF for one residue
  - Reads coordinates from an XYZ (ignoring xyz atom names)
  - Generates bonds (from RTF), auto-generated angles & dihedrals
  - Writes a CHARMM-style PSF file (atoms, bonds, angles, dihedrals)
Limitations:
  - Single-residue only
  - No patch or improper definitions from RTF
  - No nonbond parameters in PSF
"""
import argparse
import re
import sys
from itertools import combinations

# -------------------- Parsing functions --------------------

def parse_rtf(rtf_path):
    """
    Parse MASS, RESI, ATOM, BOND from RTF.
    Returns: mass_info, residue_name, atoms_list, bonds_list
    atoms_list: list of dicts {name,type,charge}
    bonds_list: list of (atom_name1, atom_name2)
    """
    mass_info = {}
    atoms = []
    bonds = []
    resname = None
    in_resi = False
    with open(rtf_path) as f:
        for line in f:
            line = line.strip()
            if line.startswith('MASS'):
                parts = line.split()
                atom_type = parts[2]
                mass = float(parts[3])
                mass_info[atom_type] = mass
            elif line.startswith('RESI'):
                parts = line.split()
                resname = parts[1]
                in_resi = True
            elif in_resi:
                if line == 'END':
                    break
                if line.startswith('ATOM'):
                    parts = line.split()
                    # ATOM <name> <type> <charge>
                    name, atype, charge = parts[1], parts[2], float(parts[3])
                    atoms.append({
                        'name': name,
                        'type': atype,
                        'charge': charge
                    })
                elif line.startswith('BOND'):
                    parts = line.split()
                    bonds.append((parts[1], parts[2]))
    if resname is None:
        raise RuntimeError('No RESI block found in RTF')
    return mass_info, resname, atoms, bonds


def read_xyz(xyz_path):
    """
    Read coordinates from XYZ, return list of (x,y,z).
    Ignores the atom name in XYZ.
    """
    coords = []
    with open(xyz_path) as f:
        natoms = int(f.readline().split()[0])
        f.readline()  # comment line
        for line in f:
            parts = line.split()
            if len(parts) < 4:
                continue
            x, y, z = map(float, parts[-3:])
            coords.append((x, y, z))
    if len(coords) != natoms:
        raise RuntimeError(f"XYZ atom count mismatch: header {natoms}, found {len(coords)}")
    return coords

# ------------------ Topology generators ------------------

def build_adjacency(bonds):
    """Return adjacency dict: atom -> set(neighbors)"""
    adj = {}
    for a, b in bonds:
        adj.setdefault(a, set()).add(b)
        adj.setdefault(b, set()).add(a)
    return adj


def generate_angles(bonds, atom_index):
    """Auto-generate angles i-j-k where bonds (i,j) & (j,k) exist."""
    adj = build_adjacency(bonds)
    angles = []
    seen = set()
    for j, neighbors in adj.items():
        for i, k in combinations(neighbors, 2):
            idx = (atom_index[i], atom_index[j], atom_index[k])
            # preserve order by index to avoid duplicates
            if idx in seen:
                continue
            seen.add(idx)
            angles.append(idx)
    return angles


def generate_dihedrals(bonds, atom_index):
    """Auto-generate dihedrals i-j-k-l where bonds exist between each adjacent pair."""
    adj = build_adjacency(bonds)
    dihedrals = []
    seen = set()
    # for each central bond j-k
    for j, ks in adj.items():
        for k in ks:
            # neighbors of j excluding k
            for i in adj[j] - {k}:
                # neighbors of k excluding j
                for l in adj[k] - {j}:
                    quad = (atom_index[i], atom_index[j], atom_index[k], atom_index[l])
                    if quad in seen:
                        continue
                    seen.add(quad)
                    dihedrals.append(quad)
    return dihedrals

# -------------------- PSF writer --------------------

def write_psf(psf_path, mass_info, resname, atoms, coords, bonds, angles, dihedrals):
    """Write a CHARMM PSF file with atoms, bonds, angles, dihedrals."""
    natoms = len(atoms)
    with open(psf_path, 'w') as f:
        # Title
        f.write("PSF\n")
        f.write(f"    2 !NTITLE\n")
        f.write("* PSF generated by pure-Python script\n")
        f.write("*\n")
        # Atoms
        f.write(f" {natoms:>8d} !NATOM\n")
        atom_index = {}
        for i, atom in enumerate(atoms, start=1):
            atom_index[atom['name']] = i
            mass = mass_info.get(atom['type'], 0.0)
            f.write(
                f"{i:8d} {resname:<4s} {1:4d} {resname:<4s} "  # seg, res#, resname
                f"{atom['name']:<4s} {atom['type']:<4s} "
                f"{atom['charge']:12.6f} {mass:12.4f}\n"
            )
        # Bonds
        nb = len(bonds)
        f.write(f"\n {nb:>8d} !NBOND: bonds\n")
        for idx, (a, b) in enumerate(bonds):
            ia, ib = atom_index[a], atom_index[b]
            f.write(f"{ia:8d}{ib:8d}")
            if (idx+1) % 4 == 0 or idx == nb-1:
                f.write("\n")
        # Angles
        ntheta = len(angles)
        f.write(f"\n {ntheta:>8d} !NTHETA: angles\n")
        for idx, (i,j,k) in enumerate(angles):
            f.write(f"{i:8d}{j:8d}{k:8d}")
            if (idx+1) % 3 == 0 or idx == ntheta-1:
                f.write("\n")
        # Dihedrals
        nphi = len(dihedrals)
        f.write(f"\n {nphi:>8d} !NPHI: dihedrals\n")
        for idx, (i,j,k,l) in enumerate(dihedrals):
            f.write(f"{i:8d}{j:8d}{k:8d}{l:8d}")
            if (idx+1) % 2 == 0 or idx == nphi-1:
                f.write("\n")
    print(f"PSF written: {psf_path}")

# -------------------- Main --------------------

def main():
    p = argparse.ArgumentParser(description="Generate PSF from RTF+XYZ in pure Python")
    p.add_argument('--rtf', required=True)
    p.add_argument('--xyz', required=True)
    p.add_argument('--psf', required=True)
    args = p.parse_args()

    mass_info, resname, atoms, bonds = parse_rtf(args.rtf)
    coords = read_xyz(args.xyz)

    # Verify same atom count
    if len(atoms) != len(coords):
        print(f"Mismatch: RTF atoms={len(atoms)} vs XYZ coords={len(coords)}", file=sys.stderr)
        sys.exit(1)

    # Build index map
    atom_index = {atom['name']: idx for idx, atom in enumerate(atoms, start=1)}

    # Generate angles & dihedrals
    angles = generate_angles(bonds, atom_index)
    dihedrals = generate_dihedrals(bonds, atom_index)

    # Write PSF
    write_psf(args.psf, mass_info, resname, atoms, coords, bonds, angles, dihedrals)

if __name__ == '__main__':
    main()
